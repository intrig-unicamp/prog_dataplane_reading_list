<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-11-05 Mon 20:57 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Programmable Data Plane: Reading List</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Roberto Bifulco, Stefan Schmid, Gábor Rétvári" />
<meta name="description" content="The Programmable Data Plane Reading List"
 />
<meta name="keywords" content="programmable switch,software-defined networks,SDN,OpenFlow,P4" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<style>.example{border:0px solid; background:#ffffff; padding:0px; margin-top:0px;margin-bottom:0px;font-family:"Bitstream Vera Sans", Verdana, sans-serif;font-style: italic;}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">The Programmable Data Plane: Reading List</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org83b4547">Abstractions</a>
<ul>
<li><a href="#org6a631ba">Languages and Compilers</a>
<ul>
<li><a href="#orgbb1bc45">Low-level APIs</a></li>
<li><a href="#orgd349aa9">High-level Languages and Compilers</a></li>
</ul>
</li>
<li><a href="#orga377eb1">Abstractions for Embedded State</a></li>
<li><a href="#org9e83241">Programmable Parsing and Scheduling</a></li>
</ul>
</li>
<li><a href="#orge50cf97">Architecture</a>
<ul>
<li><a href="#orgf2f69b7">Software Switch Architectures</a>
<ul>
<li><a href="#org1fd62ff">Viability of Software Switching</a></li>
<li><a href="#org7bac2ad">The Dataflow Graph Abstraction</a></li>
<li><a href="#orge3985f5">The Match-action Abstraction</a></li>
<li><a href="#orge201386">Packet I/O Libraries</a></li>
</ul>
</li>
<li><a href="#org739b561">Hardware Switch Architectures</a></li>
<li><a href="#org032f106">Hybrid Hardware/Software Architectures</a></li>
</ul>
</li>
<li><a href="#orgaa8c1e3">Applications</a>
<ul>
<li><a href="#org5ae0b33">Resilient, Robust, and Efficient Forwarding</a></li>
<li><a href="#org0c2dd63">In-network Computation</a></li>
<li><a href="#org38750f6">Distributed Consensus</a></li>
<li><a href="#orgf7fdbb2">Monitoring, Telemetry, and Measurement</a></li>
<li><a href="#orgb7b49da">Load balancing</a></li>
</ul>
</li>
<li><a href="#org6d5b91d">Miscellaneous Topics</a>
<ul>
<li><a href="#orgd3b5f65">History</a></li>
<li><a href="#org679d3c5">Deployments</a></li>
<li><a href="#orgbe789c8">Implementing the Match-action Abstraction: HW, Algorithms, and Data Structures</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<i>See the <a href="https://rg0now.github.io/prog_dataplane_reading_list/README.html">HTML version</a> for a nicely formatted version.</i>
</p>

<p>
This is a reading list for students, practitioners, and researchers
interested in the general area of programmable data plane devices. Topics
include SmartNICs, programmable middleboxes and software/hardware switches,
that is, everything that may underlie a software-defined network, with only
a marginal attention to the major application areas like Network Function
Virtualization, service chaining, or 5G.
</p>

<p>
The reading list completes the survey paper:
</p>

<p>
Roberto Bifulco and Gábor Rétvári:
<a href="https://rg0now.github.io/prog_dataplane_reading_list/2018_HPSR.pdf">A Survey on the Programmable Data Plane: Abstractions, Architectures, and Open Problems</a>,
in <i>IEEE HPSR</i>, 2018.
</p>

<p>
The reading list is organized into a rough hierarchy based on the major
topics of <i>Abstractions</i>, <i>Architecture</i>, <i>Applications</i>, and
<i>Miscellanea</i>; note that this hierarchy is more or less arbitrary and the
purpose is just to have <i>some</i> organization at all. The individual papers
are tagged as "mustread", "important", and "interesting" (available only in
the HTML version), with the approximate meaning "read at least these papers
to get a good understanding of the area", "papers for getting more familiar
with some sub-areas", and "interesting contributions to the field",
respectively. Just like the hierarchy, the tags are also pretty much
arbitrary and follow the subjective view of the authors; as always, your
mileage may vary.
</p>

<p>
<i>Note:</i> Some of the linked papers are behind paywalls. We double-checked
that all listed papers can be accessed freely by a moderate amount of
googling; we still provide the paywall links as user-provided PDFs often do
not prove overly stable over time.
</p>

<div id="outline-container-org83b4547" class="outline-2">
<h2 id="org83b4547">Abstractions</h2>
<div class="outline-text-2" id="text-org83b4547">
<p>
At the heart of programmable data planes lies the question of which
abstractions and programming interfaces to provide.  We first review
literature on low-level APIs, including OpenFlow and P4, and then discuss
more high-level languages and compilers, including DevoFlow and the
Frenetic framework. Particular focus is put on stateful abstractions.  We
then extend our review to literature on parser design as well as
scheduling, and in particular, the question whether there exist universal
packet scheduling algorithms.
</p>
</div>

<div id="outline-container-org6a631ba" class="outline-3">
<h3 id="org6a631ba">Languages and Compilers</h3>
<div class="outline-text-3" id="text-org6a631ba">
<p>
We start our survey with the seminal paper on OpenFlow, introducing a
standardized interface to manage flow table entries in data plane devices
via a standard control-plane&#x2013;data-plane API. We then proceed by discussing
P4 and its alternatives and use cases. We also review, among other,
high-performance packet processing languages and make the case for
intermediate representations for programmable data planes.
</p>

<p>
We then proceed to more high-level languages and abstractions, discuss
programming languages such as Pyretic, systems such as Maple, or novel
switch designs like HARMLESS to seamlessly add SDN capability to legacy
network gear.
</p>
</div>

<div id="outline-container-orgbb1bc45" class="outline-4">
<h4 id="orgbb1bc45">Low-level APIs</h4>
<div class="outline-text-4" id="text-orgbb1bc45">
</div>
<ul class="org-ul">
<li><a id="org70d3952"></a>McKeown et al.: <b><a href="http://doi.acm.org/10.1145/1355734.1355746">OpenFlow: Enabling Innovation in Campus Networks</a></b>, <i>ACM SIGCOMM Comput. Commun. Rev.</i>, 2008.<br />
<div class="outline-text-5" id="text-org70d3952">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
The OpenFlow whitepaper. The original idea in OpenFlow was to provide a way
for researchers to run experimental protocols in the networks they use
every day. OpenFlow is based on an Ethernet switch, with an internal
flow-table, and a standardized interface to add and remove flow entries.
This allowed, in addition to allowing researchers to evaluate their ideas
in real-world traffic settings, for OpenFlow to serve as a useful campus
component in large-scale testbeds.
</p>
</div>
</li>

<li><a id="org7d57371"></a>Duncan et al.: <b><a href="https://ieeexplore.ieee.org/iel5/5166953/5166954/05167027.pdf">packetC: Language for High Performance Packet Processing</a></b>, <i>IEEE HPCC</i>, 2009.<br />
<div class="outline-text-5" id="text-org7d57371">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
This paper describes a model which combines a parallel model and
heterogeneous multiprocessor implementations.  The parallel packet
processing model uses coarse-grained SPMD parallelism to free users from
thread management and it requires the host system to locate protocol
headers in the packet before a parallel copy of the program executes.  The
packetC language abstracts and encapsulates familiar packet processing data
sets and operations into new aggregate data types and operators, e.g., for
packets, databases and searchsets. 
</p>
</div>
</li>

<li><a id="orge448bcf"></a>Song et al.: <b><a href="http://doi.acm.org/10.1145/2491185.2491190">Protocol-oblivious Forwarding: Unleash the Power of SDN Through a Future-proof Forwarding Plane</a></b>, <i>ACM HotSDN</i>, 2013.<br />
<div class="outline-text-5" id="text-orge448bcf">
<pre class="example">
RELEVANCE: important
</pre>
<p>
As an alternative to P4, Protocol-Oblivious Forwarding (POF) is presented
as a key enabler for highly flexible and programmable SDN. The goal is to
remove any dependency on protocol-specific configurations on the forwarding
elements and, in addition to P4's stateless design, enhance the data-path
with new stateful instructions to support genuine software defined
networking behavior. A generic flow instruction set (FIS) is defined to
fulfill this purpose and both hardware-based and open source software-based
prototypes are shown to demonstrate the feasibility and advantages of POF.
</p>
</div>
</li>

<li><a id="orgbf61592"></a>Bosshart et al.: <b><a href="http://www.sigcomm.org/sites/default/files/ccr/papers/2014/July/0000000-0000004.pdf">P4: Programming protocol-independent packet processors</a></b>, <i>ACM SIGCOMM Comput. Commun. Rev.</i>, 2014.<br />
<div class="outline-text-5" id="text-orgbf61592">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
This seminal paper introduces P4, a high-level language for programming
protocol-independent packet processors. P4 has three goals: (1)
reconfigurability, in that programmers can change the way switches process
packets once they are deployed, (2) protocol independence, in that switches
are not tied to any specific network protocols, and (3) target
independence, in that programmers can describe packet-processing
functionality independently of the specifics of the underlying
hardware. The paper demonstrates P4 by showing configure a switch to add a
new hierarchical label.
</p>
</div>
</li>

<li><a id="org433d605"></a>Sivaraman et al.: <b><a href="http://doi.acm.org/10.1145/2774993.2775007">DC.P4: Programming the Forwarding Plane of a Data-center Switch</a></b>, <i>ACM SOSR</i>, 2015.<br />
<div class="outline-text-5" id="text-org433d605">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The paper presents a case study that uses P4 to express the forwarding behavior 
of a datacenter switch's data plane. In the process, it identifies issues and
strengths of P4. Some of the lessons learned had, and are having, an impact on
the language evolution. For instance, and most notably, the 
language-architecture separation that has been implemented in newer versions of 
P4.
</p>
</div>
</li>

<li><a id="orge701b9b"></a>Shahbaz et al.: <b><a href="http://doi.acm.org/10.1145/2774993.2775000">The Case for an Intermediate Representation for Programmable Data Planes</a></b>, <i>ACM SOSR</i>, 2015.<br />
<div class="outline-text-5" id="text-orge701b9b">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The paper introduces NetASM, an intermediate representation for
programmable data planes. NetASM is a device-independent language that is
expressive enough to act as the target language for compilers for
high-level languages, yet low-level enough to be efficiently assembled on
various device architectures. It enables conventional compiler optimization
techniques to significantly improve the performance and resource
utilization of custom packet-processing pipelines on a variety of targets.
</p>
</div>
</li>

<li><a id="org35ad64a"></a>Bifulco et al.: <b><a href="http://doi.acm.org/10.1145/2890955.2890962">Improving SDN with InSPired Switches</a></b>, <i>ACM SOSR</i>, 2016.<br />
<div class="outline-text-5" id="text-org35ad64a">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
The paper proposes an API for programming the generation of packets in
programmable switches, instead of forging network packets on the controller
side.  The InSP API allows a programmer to define in-switch packet
generation operations, which include the specification of triggering
conditions, packet's content and forwarding actions.
</p>
</div>
</li>

<li><a id="orgd6fa3f0"></a>Choi et al.: <b><a href="https://www.cs.princeton.edu/~mshahbaz/papers/sosr17demos-pvpp.pdf">PVPP: A Programmable Vector Packet Processor</a></b>, <i>ACM SOSR</i>, 2017.<br />
<div class="outline-text-5" id="text-orgd6fa3f0">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
PVPP is a data-plane program compiler from P4, a data plane DSL based on
match-action tables, to the fd.io Vector Packet Processor (VPP) software
switch, based on the packet processing node graph model. PVPP compiles a
data plane program written in P4 to VPP's internal graph
representation. 
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgd349aa9" class="outline-4">
<h4 id="orgd349aa9">High-level Languages and Compilers</h4>
<div class="outline-text-4" id="text-orgd349aa9">
</div>
<ul class="org-ul">
<li><a id="orgc501843"></a>Curtis et al.: <b><a href="https://conferences.sigcomm.org/sigcomm/2011/papers/sigcomm/p254.pdf">DevoFlow: scaling flow management for high-performance networks</a></b>, <i>SIGCOMM CCR</i>, 2011.<br />
<div class="outline-text-5" id="text-orgc501843">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
This paper is motivated by the observation that OpenFlow, in its original
design, imposes great overheads, involving the switch’s control-plane too
often.  In order to meet the needs of high-performance networks, the
authors propose and evaluate DevoFlow, which provides less fine-grained
visibility, at significantly lower costs. In a case study, the authors show
that DevoFlow can load-balance data center traffic as well as fine-grained
solutions, but with much fewer flow table entries and using much fewer
control messages.
</p>
</div>
</li>

<li><a id="orgc4e41db"></a>Christopher Monsanto et al.: <b><a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final232.pdf">Composing Software Defined Networks</a></b>, <i>USENIX NSDI</i>, 2013.<br />
<div class="outline-text-5" id="text-orgc4e41db">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
The paper introduces Pyretic, a novel programming language for writing
composable SDN applications using a set of high level topology and
packet-processing abstractions. Pyretic improves on Frenetic (an earlier
incarnation of a similar language) by adding support for sequential
composition, the use of topology abstractions to define what each module
can see and do with the network, and an abstract packet model that
introduces virtual fields into packets. Modular applications are written
using the static policy language NetCore, which provides primitive actions,
matching predicates, query policies, and policies.
</p>
</div>
</li>

<li><a id="orgbc31f7b"></a>Voellmy et al.: <b><a href="https://conferences.sigcomm.org/sigcomm/2013/papers/sigcomm/p87.pdf">Maple: simplifying SDN programming using algorithmic policies</a></b>, <i>ACM SIGCOMM Comput. Commun. Rev.</i>, 2013.<br />
<div class="outline-text-5" id="text-orgbc31f7b">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The paper presents Maple, a system that simplifies SDN programming by (1)
allowing a programmer to use a standard programming language to design an
arbitrary, centralized algorithm, to decide the behavior of an entire
network, and (2) providing an abstraction that the programmer-defined,
centralized policy runs on every packet entering a network, and hence is
oblivious to the challenge of translating a high-level policy into sets of
rules on distributed individual switches. To implement algorithmic policies
efficiently, Maple includes not only a highly-efficient multicore
scheduler, but more importantly a novel tracing runtime optimizer that can
automatically record reusable policy decisions, offload work to switches
when possible, and keep switch flow tables up-to-date by dynamically
tracing the dependency of policy decisions on packet contents as well as
the environment. 
</p>
</div>
</li>

<li><a id="org8875b1d"></a>Foster et al.: <b><a href="http://frenetic-lang.org/publications/overview-ieeecoms13.pdf">Languages for software-defined networks</a></b>, <i>IEEE Communications Magazine</i>, 2013.<br />
<div class="outline-text-5" id="text-org8875b1d">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
An easily approachable survey on higher-level abstractions for creating and
composing packet processing applications using the Frenetic framework.
</p>
</div>
</li>

<li><a id="org6fbd47c"></a>Bonelli et al.: <b><a href="http://doi.acm.org/10.1145/2658260.2658269">A Purely Functional Approach to Packet Processing</a></b>, <i>IEEE/ACM ANCS</i>, 2014.<br />
<div class="outline-text-5" id="text-org6fbd47c">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper introduces PFQ-Lang, an extensible functional language to
process, analyze and forward packets, which allows easy development by
leveraging functional composition and allows to exploit multi-queue NICs
and multi-core architectures.
</p>
</div>
</li>

<li><a id="orgf631ae0"></a>Schiff et al.: <b><a href="https://dl.acm.org/citation.cfm?id=2673874">Reclaiming the Brain: Useful OpenFlow Functions in the Data Plane</a></b>, <i>ACM HotNets</i>, 2014.<br />
<div class="outline-text-5" id="text-orgf631ae0">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
Schiff et al. show that standard OpenFlow can be exploited to implement
powerful functionality in the data plane, e.g., to reduce the number of
interactions with the control plane or to render the network more robust.
Example applications of such a SmartSouth include topology snapshot,
anycast, blackhole detection and critical node detection.
</p>
</div>
</li>

<li><a id="org68d327e"></a>Lavanya Jose et al.: <b><a href="https://www.usenix.org/conference/nsdi15/technical-sessions/presentation/jose">Compiling Packet Programs to Reconfigurable Switches</a></b>, <i>USENIX NSDI</i>, 2015.<br />
<div class="outline-text-5" id="text-org68d327e">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
Seminal paper exploring the design of a compiler for programmable switching
chips, in particular how to map logical lookup tables to physical tables
while meeting data and control dependencies in the program. A Integer
Linear Programming (ILP) and greedy approach is presented to generate
solutions optimized for latency, pipeline occupancy, or power
consumption. The authors show benchmarks from real production networks to
two different programmable switch architectures: RMT and Intel’s FlexPipe.
</p>
</div>
</li>

<li><a id="orgd190458"></a>Firestone et al.: <b><a href="https://www.usenix.org/system/files/conference/nsdi17/nsdi17-firestone.pdf">VFP: A Virtual Switch Platform for Host SDN in the Public Cloud</a></b>, <i>USENIX NSDI</i>, 2017.<br />
<div class="outline-text-5" id="text-orgd190458">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The paper presents the Virtual Filtering Platform (VFP), a programmable
virtual switch that powers Microsoft Azure, a large public cloud. VFP
includes support for multiple independent network controllers, policy based
on connections rather than only on packets, efficient caching and
classification algorithms for performance, and efficient offload of flow
policy to programmable NICs. The paper presents the design of VFP and its
API, its flow language and compiler used for flow processing, performance
results, and experiences deploying and using VFP in Azure over several
years.
</p>
</div>
</li>

<li><a id="org003dc01"></a>Wang et al.: <b><a href="https://www.cs.cornell.edu/~jnfoster/papers/p4fpga.pdf">P4FPGA: A Rapid Prototyping Framework for P4</a></b>, <i>ACM SOSR</i>, 2017.<br />
<div class="outline-text-5" id="text-org003dc01">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
P4FPGA is a tool for developing and evaluating data plane applications. It
is both an open-source compiler and runtime; the compiler in turn extends
the P4.org reference compiler with a custom backend that generates FPGA
code. By combining high-level programming abstractions offered by P4 with a
flexible and powerful hardware target, P4FPGA may allow developers to
rapidly prototype and deploy new data plane applications.
</p>
</div>
</li>

<li><a id="orga2e84b6"></a>Csikor et al.: <b><a href="http://lendulet.tmit.bme.hu/lendulet_website/wp-content/papercite-data/pdf/csikor2018networking.pdf">HARMLESS: Cost-Effective Transitioning to SDN for Small Enterprises</a></b>, <i>IFIP Netwoking</i>, 2018.<br />
<div class="outline-text-5" id="text-orga2e84b6">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper proposes HARMLESS, a new SDN switch design that seamlessly adds
SDN capability to legacy network gear, by emulating the OpenFlow switch OS
in a separate software switch component. This way, HARMLESS enables a quick
and easy leap into SDN, combining the rapid innovation and upgrade cycles
of software switches with the port density and cost-efficiency of
hardware-based appliances into a fully dataplane-transparent and
vendor-neutral solution. HARMLESS incurs an order of magnitude smaller
initial expenditure for an SDN deployment than existing turnkey vendor SDN
solutions while it yields matching, or even better data plane performance
for smaller enterprises.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orga377eb1" class="outline-3">
<h3 id="orga377eb1">Abstractions for Embedded State</h3>
<div class="outline-text-3" id="text-orga377eb1">
<p>
While OpenFlow match/action table abstractions are stateless, there are
many efforts toward devising a stateful data plane programming abstraction,
e.g., based on finite state machines, for supporting more dynamic
applications.  We discuss such approaches as well as first workload
characterizations of stateful networking applications.  We also review
literature on the challenge of consistent state migration and elastic
scaling, and discuss security implications.
</p>
</div>

<ul class="org-ul">
<li><a id="org06a6ef7"></a>Verdú et al.: <b><a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=ED2CCB19D8967081D9DE927A7AB43614?doi=10.1.1.482.5955&amp;rep=rep1&amp;type=pdf">Workload Characterization of Stateful Networking Applications</a></b>, <i>IEEE HPC</i>, 2008.<br />
<div class="outline-text-5" id="text-org06a6ef7">
<pre class="example">
RELEVANCE: important
</pre>
<p>
This paper presents the first workload characterization of stateful
networking applications. The analysis emphasizes the study of data cache
behavior, but discusses branch prediction, instruction distribution,
etc. Another important contribution is the study of the state categories of
different networking applications. 
</p>
</div>
</li>

<li><a id="orga00426e"></a>Bianchi et al.: <b><a href="http://doi.acm.org/10.1145/2602204.2602211">OpenState: Programming Platform-independent Stateful Openflow Applications Inside the Switch</a></b>, <i>ACM SIGCOMM Comput. Commun. Rev.</i>, 2014.<br />
<div class="outline-text-5" id="text-orga00426e">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
The paper tackles the challenge to devise a stateful data plane programming
abstraction (versus the stateless OpenFlow match/action table abstraction)
which still entails high performance and remains consistent with vendors'
preference for closed platforms. The authors posit that a promising answer
revolves around the usage of extended finite state machines, as an
extension (super-set) of the OpenFlow match/action abstraction, turn the
proposed abstraction into an actual table-based API, and show how it can
be supported by (mostly) reusing core primitives already implemented in
OpenFlow devices.
</p>
</div>
</li>

<li><a id="orgd7f778b"></a>Moshref et al.: <b><a href="http://doi.acm.org/10.1145/2620728.2620729">Flow-level State Transition As a New Switch Primitive for SDN</a></b>, <i>ACM HotSDN</i>, 2014.<br />
<div class="outline-text-5" id="text-orgd7f778b">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper proposes FAST (Flow-level State Transitions) as a new switch
primitive for software-defined networks. With FAST, the controller simply
preinstalls a state machine and switches can automatically record flow
state transitions by matching incoming packets to installed filters. FAST
can support a variety of dynamic applications, and can be readily
implemented with commodity switch components and software switches.
</p>
</div>
</li>

<li><a id="orgdc64b5c"></a>Arashloo et al.: <b><a href="http://doi.acm.org/10.1145/2934872.2934892">SNAP: Stateful Network-Wide Abstractions for Packet Processing</a></b>, <i>ACM SIGCOMM</i>, 2016.<br />
<div class="outline-text-5" id="text-orgdc64b5c">
<pre class="example">
RELEVANCE: important
</pre>
<p>
SNAP offers a simpler "centralized" stateful programming model on top of
the simple match-action paradigm offered by OpenFlow.  SNAP programs are
developed on a one-big-switch abstraction and may contain reads and writes
to global, persistent arrays, allowing programmers to implement a broad
range of stateful applications. The SNAP compiler then distributes, places,
and optimizes access to these stateful arrays, discovering read/write
dependencies and translating one-big-switch programs into an efficient
internal representation based on a novel variant of binary decision
diagrams.
</p>
</div>
</li>

<li><a id="org72d66f1"></a>Kim et al.: <b><a href="http://dl.acm.org/citation.cfm?id=2789770.2789775">Kinetic: Verifiable Dynamic Network Control</a></b>, <i>USENIX NSDI</i>, 2015.<br />
<div class="outline-text-5" id="text-org72d66f1">
<pre class="example">
RELEVANCE: important
</pre>
<p>
Kinetic provides a formal way to program the network control plane using 
finite state machines. The use of a formal language allows the system to
verify the correctness of the control program according to user-specified
temporal properties. The paper also reports about a user survey among students
of the Coursera's SDN course, which find the Finite State Machine abstraction
of Kinetic to be intuitive and easier to verify compared to other high-level
languages, such as Pyretic.
</p>
</div>
</li>

<li><a id="org0f47512"></a>Sivaraman et al.: <b><a href="http://doi.acm.org/10.1145/2934872.2934900">Packet Transactions: High-Level Programming for Line-Rate Switches</a></b>, <i>ACM SIGCOMM</i>, 2016.<br />
<div class="outline-text-5" id="text-org0f47512">
<pre class="example">
RELEVANCE: important
</pre>
<p>
This paper shows how to program data-plane algorithms in a high-level
language and compile those programs into low-level microcode that can run
on programmable line-rate switching chips. The key challenge is that many
data-plane algorithms create and modify algorithmic state. To achieve
line-rate programmability for stateful algorithms, the paper introduces the
notion of a packet transaction: a sequential packet-processing code block
that is atomic and isolated from other such code blocks. The idea is
developed in Domino, a C-like imperative language to express data-plane
algorithms, and many examples are shown that can be run at line rate with
modest estimated chip-area overhead.
</p>
</div>
</li>

<li><a id="org6bf3b8b"></a>Giuseppe Bianchi et al.: <b><a href="http://arxiv.org/abs/1605.01977">Open Packet Processor: a programmable architecture for wire speed platform-independent stateful in-network processing</a></b>, <i>unpublished manuscript</i>, 2016.<br />
<div class="outline-text-5" id="text-org6bf3b8b">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
This paper aims at contributing to the debate on how to bring
programmability of stateful packet processing tasks inside the network
switches, while retaining platform independence. The proposed approach,
named "Open Packet Processor" (OPP), shows the viability of eXtended Finite
State Machines (XFSM) as low-level data plane programming
abstraction. Platform independence is accomplished by decoupling the
implementation of hardware primitives from their usage by an application
formally described via an abstract XFSM.
</p>
</div>
</li>

<li><a id="org5ab4c5e"></a>Junaid Khalid et al.: <b><a href="https://www.usenix.org/conference/nsdi16/technical-sessions/presentation/khalid">Paving the Way for NFV: Simplifying Middlebox Modifications Using StateAlyzr</a></b>, <i>USENIX NSDI 16</i>, 2016.<br />
<div class="outline-text-5" id="text-org5ab4c5e">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
Migrating/cloning internal state in elastically scalable Network Functions
Virtualization (NFV) require modifications to middlebox code to identify
needed state. The paper presents a framework-independent system,
StateAlyzr, that embodies novel algorithms adapted from program analysis to
provably and automatically identify all state that must be migrated/cloned
to ensure consistent middlebox output in the face of
redistribution. StateAlyzr reduces man-hours required for code modification
by nearly 20x.
</p>
</div>
</li>

<li><a id="org9194196"></a>Luo et al.: <b><a href="http://doi.acm.org/10.1145/3050220.3050233">Swing State: Consistent Updates for Stateful and Programmable Data Planes</a></b>, <i>ACM SOSR</i>, 2017.<br />
<div class="outline-text-5" id="text-org9194196">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper presents Swing State, a general state-management framework and
runtime system supporting consistent state migration in stateful data
planes. The key insight is to perform state migration entirely within the
data plane by piggybacking state updates on live traffic. To minimize the
overhead, Swing State only migrates the states that cannot be safely
reconstructed at the destination switch. A prototype of Swing State for P4
is also described.
</p>
</div>
</li>

<li><a id="orgdff608a"></a>Dargahi et al.: <b><a href="https://doi.org/10.1109/COMST.2017.2689819">A Survey on the Security of Stateful SDN Data Planes</a></b>, <i>IEEE Communications Surveys Tutorials</i>, 2017.<br />
<div class="outline-text-5" id="text-orgdff608a">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The paper provides the reader with a background on stateful SDN data plane
proposals, focusing on the security implications that data plane
programmability brings about, identifies potential attack scenarios, and
highlights possible vulnerabilities specific to stateful in-switch
processing, including denial of service and saturation attacks.
</p>
</div>
</li>

<li><a id="orgd3c79cd"></a>Murad Kablan et al.: <b><a href="https://www.usenix.org/conference/nsdi17/technical-sessions/presentation/kablan">Stateless Network Functions: Breaking the Tight Coupling of State and Processing</a></b>, <i>USENIX NSDI 17</i>, 2017.<br />
<div class="outline-text-5" id="text-orgd3c79cd">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
The paper presents Stateless Network Functions, a new architecture for
network functions virtualization, where the existing design of network
functions is decomposed into a stateless processing component along with a
data-store layer. The StatelessNF processing instances are architected
around efficient pipelines utilizing DPDK for high performance network I/O,
packaged as Docker containers for easy deployment, and a data store
interface optimized based on the expected request patterns to efficiently
access a RAMCloud-based data store. A network-wide orchestrator monitors
the instances for load and failure, manages instances to scale and provide
resilience, and leverages an OpenFlow-based network to direct traffic to
instances. 
</p>
</div>
</li>

<li><a id="org946135a"></a>Shinae Woo et al.: <b><a href="https://www.usenix.org/conference/nsdi18/presentation/woo">Elastic Scaling of Stateful Network Functions</a></b>, <i>USENIX NSDI 18</i>, 2018.<br />
<div class="outline-text-5" id="text-org946135a">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
Elastic scaling is a central promise of NFV but has been hard to realize in
practice, because most Network Functions (NFs) are stateful and this state
need to be shared across NF instances. The paper presents S6, building on
the insight that a distributed shared state abstraction is well-suited to
the NFV context. State is organized as a distributed shared object (DSO)
space, extended with techniques designed to meet the need for elasticity
and high-performance in NFV workloads.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org9e83241" class="outline-3">
<h3 id="org9e83241">Programmable Parsing and Scheduling</h3>
<div class="outline-text-3" id="text-org9e83241">
<p>
We start by reviewing design principles for packet parsers.
We then revisit the concept of a universal scheduler that
would handle all queuing strategies that may arise in a programmable
switch, and ask whether such a scheduling algorithm can really exist. 
We conclude with a review of fair queuing on reconfigurable switches.
</p>
</div>

<ul class="org-ul">
<li><a id="orgb952774"></a>Gibb et al.: <b><a href="https://doi.org/10.1109/ANCS.2013.6665172">Design principles for packet parsers</a></b>, <i>IEEE/ACM ANCS</i>, 2013.<br />
<div class="outline-text-5" id="text-orgb952774">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The paper presents an interesting view on parser design and the trade-offs
between different designs, asking whether it is better to design one fast
parser or several slow parsers, what are the costs of making the parser
reconfigurable in the field, and what design decisions most impact power
and area. The paper describes trade-offs in parser design, identifies
design principles for switch and router architects, and describes a parser
generator that outputs synthesizable Verilog that is available for
download.
</p>
</div>
</li>

<li><a id="org988602a"></a>Sivaraman et al.: <b><a href="http://doi.acm.org/10.1145/2535771.2535796">No Silver Bullet: Extending SDN to the Data Plane</a></b>, <i>ACM HotNets</i>, 2013.<br />
<div class="outline-text-5" id="text-org988602a">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The authors argue that, instead of going with a universal scheduler that
would handle all queuing strategies that may arise in a programmable
switch, Software-Defined Networking must be extended to control the
fast-path scheduling and queuing behavior of a switch. To this end, they
propose adding a small FPGA to switches, and synthesize, place, and route
hardware implementations for CoDel and RED.
</p>
</div>
</li>

<li><a id="org5e3b20a"></a>Radhika Mittal et al.: <b><a href="https://www.usenix.org/conference/nsdi16/technical-sessions/presentation/mittal">Universal Packet Scheduling</a></b>, <i>USENIX NSDI</i>, 2016.<br />
<div class="outline-text-5" id="text-org5e3b20a">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The addresses a seemingly simple question: Is there a universal packet
scheduling algorithm? It turns out that in general the answer is "no";
however, the authors manage to show that the classical Least Slack Time
First (LSTF) scheduling algorithm comes closest to being universal and it
can closely replay a wide range of scheduling algorithms. LSTF is evaluated
as to whether in practice it can meet various network-wide objectives; the
authors find that LSTF performs comparable to the state-of-the-art for each
of performance metric. 
</p>
</div>
</li>

<li><a id="orgd995809"></a>Sivaraman et al.: <b><a href="http://doi.acm.org/10.1145/2934872.2934899">Programmable Packet Scheduling at Line Rate</a></b>, <i>ACM SIGCOMM</i>, 2016.<br />
<div class="outline-text-5" id="text-orgd995809">
<pre class="example">
RELEVANCE: important
</pre>
<p>
Similarly to the "Universal Packet Scheduling" paper, this paper presents
another design for a programmable packet scheduler, which allows scheduling
algorithms, potentially algorithms that are unknown today, to be programmed
into a switch without requiring hardware redesign.  The design uses the
property that scheduling algorithms make two decisions, in what order to
schedule packets and when to schedule them, and exploits that in many
scheduling algorithms definitive decisions on these two questions can be
made when packets are enqueued. The resultant design uses a single
abstraction: the push-in first-out queue (PIFO), a priority queue that
maintains the scheduling order or time.
</p>
</div>
</li>

<li><a id="orgf18b5bd"></a>Naveen Sharma et al.: <b><a href="https://www.usenix.org/conference/nsdi18/presentation/sharma">Approximating Fair Queueing on Reconfigurable Switches</a></b>, <i>USENIX NSDI</i>, 2018.<br />
<div class="outline-text-5" id="text-orgf18b5bd">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper discusses how to leverage configurable per-packet processing and
the ability to maintain mutable state inside switches to achieve fair
bandwidth allocation across all traversing flows. The problem is that
implementing fair queuing mechanisms in high-speed switches is expensive,
since they require complex flow classification, buffer allocation, and
scheduling on a per-packet basis. The proposed dequeuing scheduler, called
Rotating Strict Priority scheduler, simulates an ideal round-robin scheme
where each active flow transmits a single bit of data in every round, which
allows to transmit packets from multiple queues in approximately sorted
order.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orge50cf97" class="outline-2">
<h2 id="orge50cf97">Architecture</h2>
<div class="outline-text-2" id="text-orge50cf97">
<p>
We divide the discussion of switch architectures into software and hardware
switch architectures.
</p>
</div>

<div id="outline-container-orgf2f69b7" class="outline-3">
<h3 id="orgf2f69b7">Software Switch Architectures</h3>
<div class="outline-text-3" id="text-orgf2f69b7">
<p>
We first discuss the viability of software switching and then review
dataflow graph abstractions, also discussing, e.g., Click, ClickOS, and
software NICs.  We proceed by revisiting literature on match-action
abstractions, discussing OVS and PISCES.  We conclude with a review on
packet I/O libraries.
</p>
</div>

<div id="outline-container-org1fd62ff" class="outline-4">
<h4 id="org1fd62ff">Viability of Software Switching</h4>
<div class="outline-text-4" id="text-org1fd62ff">
</div>
<ul class="org-ul">
<li><a id="org97f2565"></a>Egi et al.: <b><a href="http://doi.acm.org/10.1145/1544012.1544032">Towards High Performance Virtual Routers on Commodity Hardware</a></b>, <i>ACM CoNEXT</i>, 2008.<br />
<div class="outline-text-5" id="text-org97f2565">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper is the first to study the performance limitations when building
both software routers and software virtual routers on commodity CPU
platforms. The authors observe that the fundamental performance bottleneck
is the memory system, and that through careful mapping of tasks to CPU
cores one can achieve very high forwarding rates. The authors also identify
principles for the construction of high-performance software router systems
on commodity hardware.
</p>
</div>
</li>

<li><a id="orgd581954"></a>Greenhalgh et al.: <b><a href="http://www.sigcomm.org/sites/default/files/ccr/papers/2009/April/1517480-1517484.pdf">Flow Processing and the Rise of Commodity Network Hardware</a></b>, <i>SIGCOMM Comput. Commun. Rev.</i>, 2009.<br />
<div class="outline-text-5" id="text-orgd581954">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
The paper introduces the FlowStream switch architecture, which enables flow
processing and forwarding at unprecedented flexibility and low cost by
consolidating middlebox functionality, such as load balancing, packet
inspection and intrusion detection, and commodity switch technologies,
offering the possibility to control the switching of flows in a
fine-grained manner, into a single integrated package deployed on commodity
hardware.
</p>
</div>
</li>

<li><a id="org1cfdd8b"></a>Dobrescu et al.: <b><a href="http://kfall.net/ucbpage/papers/sosp09.pdf">RouteBricks: exploiting parallelism to scale software routers</a></b>, <i>ACM SOSP</i>, 2009.<br />
<div class="outline-text-5" id="text-org1cfdd8b">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
RouteBricks is concerned with enabling high-speed parallel processing in
software routers, using a software router architecture that parallelizes
router functionality both across multiple servers and across multiple cores
within a single server. RouteBricks adopts a fully programmable Click/Linux
environment and is built entirely from off-the-shelf, general-purpose
server hardware.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org7bac2ad" class="outline-4">
<h4 id="org7bac2ad">The Dataflow Graph Abstraction</h4>
<div class="outline-text-4" id="text-org7bac2ad">
</div>
<ul class="org-ul">
<li><a id="org91098cb"></a>Morris et al.: <b><a href="https://pdos.csail.mit.edu/papers/click:tocs00/paper.pdf">The Click modular router</a></b>, <i>ACM Trans. on Computer Systems</i>, 2000.<br />
<div class="outline-text-5" id="text-org91098cb">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
Introduces Click, a software architecture for building flexible and
configurable routers from packet processing modules implementing simple
router functions like packet classification, queuing, scheduling, organized
into a directed graph with packet processing modules at the vertices;
packets flow along the edges of the graph.
</p>
</div>
</li>

<li><a id="org3ff4be5"></a>Sun et al.: <b><a href="https://dl.acm.org/citation.cfm?id=2537861">Fast and Flexible: Parallel Packet Processing with GPUs and Click</a></b>, <i>IEEE/ACM ANCS</i>, 2013.<br />
<div class="outline-text-5" id="text-org3ff4be5">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The paper introduces Snap, a framework for packet processing that exploits
the parallelism available on modern GPUs, while remaining flexible, with
packet processing tasks implemented as simple modular elements that are
composed to build fully functional routers and switches. Snap is based on
the Click modular router, which it extends by adding new architectural
features that support batched packet processing, memory structures
optimized for offloading to coprocessors, and asynchronous scheduling with
in-order completion. 
</p>
</div>
</li>

<li><a id="org481aa24"></a>Sangjin Han et al.: <b><a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2015/EECS-2015-155.pdf">SoftNIC: A Software NIC to Augment Hardware</a></b>, <i>unpublished manuscript</i>, 2015.<br />
<div class="outline-text-5" id="text-org481aa24">
<pre class="example">
RELEVANCE: important
</pre>
<p>
SoftNIC is a hybrid software-hardware architecture to bridge the gap
between limited hardware capabilities and ever changing user
demands. SoftNIC provides a programmable platform that allows applications
to leverage NIC features implemented in software and hardware, without
sacrificing performance. This paper serves the foundation for the BESS
software switch.
</p>
</div>
</li>

<li><a id="org149b6c7"></a>Martins et al.: <b><a href="https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-martins.pdf">ClickOS and the Art of Network Function Virtualization</a></b>, <i>USENIX NSDI</i>, 2014.<br />
<div class="outline-text-5" id="text-org149b6c7">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
The paper introduces ClickOS, a high-performance, virtualized software
middlebox platform. ClickOS virtual machines are small (5MB), boot quickly
(about 30 milliseconds), add little delay (45 microseconds), and over one
hundred of them can be concurrently run while saturating a 10Gb pipe on a
commodity server. A wide range of middleboxes is implemented, including a
firewall, a carrier-grade NAT and a load balancer, and the evaluations
suggest that ClickOS can handle packets in the millions per second.
</p>
</div>
</li>

<li><a id="orgb61e9e0"></a>Sangjin Han et al.: <b><a href="http://span.cs.berkeley.edu/bess.html">Berkeley Extensible Software Switch</a></b>, <i>project website</i>, 2015.<br />
<div class="outline-text-5" id="text-orgb61e9e0">
<pre class="example">
RELEVANCE: important
</pre>
<p>
BESS is the Berkeley Extensible Software Switch developed at the University
of California, Berkeley and at Nefeli Networks. BESS is heavily inspired by
the Click modular router, representing a packet processing pipeline as a
dataflow (multi)graph that consists of modules, each of which implements a
NIC feature, and ports that act as sources and sinks for this
pipeline. Packets received at a port flow through the pipeline to another
port, and each module in the pipeline performs module-specific operations
on packets. 
</p>
</div>
</li>

<li><a id="org3bce815"></a>Honda et al.: <b><a href="http://doi.acm.org/10.1145/2774993.2775065">mSwitch: A Highly-scalable, Modular Software Switch</a></b>, <i>ACM SOSR</i>, 2015.<br />
<div class="outline-text-5" id="text-org3bce815">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The authors make the observation that it is difficult to simultaneously
provide high packet rates, high throughput, low CPU usage, high port
density and a flexible data plane in a same architecture. A new
architecture called mSwitch is proposed and four distinct modules are
implemented on top: a learning bridge, an accelerated Open vSwitch module,
a protocol demultiplexer for userspace protocol stacks, and a filtering
module that can direct packets to virtualized middleboxes.
</p>
</div>
</li>

<li><a id="org0ae88e8"></a>Aurojit Panda et al.: <b><a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-panda.pdf">NetBricks: Taking the V out of NFV</a></b>, <i>USENIX OSDI</i>, 2016.<br />
<div class="outline-text-5" id="text-org0ae88e8">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
NetBricks is an NFV framework adopting the "graph-based" pipeline
abstraction and embracing type checking and safe runtimes to provide
isolation efficiently in software, providing the same memory isolation as
containers and VMs without incurring the same performance penalties. The
new isolation technique is called zero-copy software isolation.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orge3985f5" class="outline-4">
<h4 id="orge3985f5">The Match-action Abstraction</h4>
<div class="outline-text-4" id="text-orge3985f5">
</div>
<ul class="org-ul">
<li><a id="org22a43dc"></a>Ben Pfaff et al.: <b><a href="https://www.usenix.org/conference/nsdi15/technical-sessions/presentation/pfaff">The Design and Implementation of Open vSwitch</a></b>, <i>USENIX NSDI</i>, 2015.<br />
<div class="outline-text-5" id="text-org22a43dc">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
The paper describes the design and implementation of Open vSwitch, a
multi-layer, open source virtual switch. The design document details the
advanced flow classification and caching techniques that Open vSwitch uses
to optimize its operations and conserve hypervisor resources.
</p>
</div>
</li>

<li><a id="orgce365cd"></a>Shahbaz et al.: <b><a href="http://doi.acm.org/10.1145/2934872.2934886">PISCES: A Programmable, Protocol-Independent Software Switch</a></b>, <i>ACM SIGCOMM</i>, 2016.<br />
<div class="outline-text-5" id="text-orgce365cd">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
PISCES is a software switch derived from Open vSwitch (OVS), a hypervisor
switch whose behavior is customized using P4. PISCES is not hard-wired to
specific protocols; this independence makes it easy to add new
features. The paper also shows how the compiler can analyze the high-level
P4 specification to optimize forwarding performance; the evaluations show
that PISCES performs comparably to OVS but PISCES programs are about 40
times shorter than equivalent OVS source code.
</p>
</div>
</li>

<li><a id="org6bc5e41"></a>Ethan Jackson et al.: <b><a href="https://www.usenix.org/conference/atc16/technical-sessions/presentation/jackson">SoftFlow: A Middlebox Architecture for Open vSwitch</a></b>, <i>USENIX ATC</i>, 2016.<br />
<div class="outline-text-5" id="text-org6bc5e41">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper presents SoftFlow, an extension to Open vSwitch that seamlessly
integrates middlebox functionality while maintaining the familiar OpenFlow
forwarding model and performing significantly better than alternative
techniques for middlebox integration.
</p>
</div>
</li>

<li><a id="orgd56d317"></a>Molnár et al.: <b><a href="http://doi.acm.org/10.1145/2934872.2934887">Dataplane Specialization for High-performance OpenFlow Software Switching</a></b>, <i>ACM SIGCOMM</i>, 2016.<br />
<div class="outline-text-5" id="text-orgd56d317">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
The authors argue that, instead of enforcing the same universal fast-path
semantics to all OpenFlow applications and optimizing for the common case,
as it is done in Open vSwitch, a programmable software switch should rather
automatically specialize its dataplane piecemeal with respect to the
configured workload. They introduce ESwitch, a switch architecture that
uses on-the-fly template-based code generation to compile any OpenFlow
pipeline into efficient machine code, which can then be readily used as the
switch fast-path, delivering superior packet processing speed, improved
latency and CPU scalability, and predictable performance.
</p>
</div>
</li>

<li><a id="org59fe316"></a>Rétvári et al.: <b><a href="https://conferences.sigcomm.org/sigcomm/2017/files/program-netpl/sigcomm17netpl-paper4.pdf">Dynamic Compilation and Optimization of Packet Processing Programs</a></b>, <i>ACM SIGCOMM NetPL</i>, 2017.<br />
<div class="outline-text-5" id="text-org59fe316">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper makes the observation that data-plane compilation is
fundamentally static, i.e., the input of the compiler is a fixed
description of the forwarding plane semantics and the output is code that
can accommodate any packet processing behavior set by the controller at
runtime. The authors advocate a dynamic approach to data plane compilation
instead, where not just the semantics but the intended behavior is
also input to the compiler, opening the door to a handful of runtime
optimization opportunities that can be leveraged to improve the performance
of custom-compiled datapaths beyond what is possible in a static setting.
</p>
</div>
</li>

<li><a id="org2fc9190"></a>Michael Dalton et al.: <b><a href="https://www.usenix.org/conference/nsdi18/presentation/dalton">Andromeda: Performance, Isolation, and Velocity at Scale in Cloud Network Virtualization</a></b>, <i>USENIX NSDI</i>, 2018.<br />
<div class="outline-text-5" id="text-org2fc9190">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
This paper presents the design and experience with Andromeda, the network
virtualization stack underlying the Google Cloud Platform. Andromeda is
designed around the Hoverboard programming model, which uses gateways for
the long tail of low bandwidth flows enabling the control plane to program
network connectivity for tens of thousands of VMs in seconds, and applies
per-flow processing to elephant flows only. The paper cites statistics
indicating that above 80% of VM pairs never talk to each other in a
deployment and only 1&#x2013;2% generate sufficient traffic to warrant per-flow
processing. The architecture also uses a high-performance OS bypass
software packet processing path for CPU-intensive per packet operations,
implemented on coprocessor threads.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orge201386" class="outline-4">
<h4 id="orge201386">Packet I/O Libraries</h4>
<div class="outline-text-4" id="text-orge201386">
</div>
<ul class="org-ul">
<li><a id="org719bc95"></a>Rizzo et al.: <b><a href="https://www.usenix.org/system/files/conference/atc12/atc12-final186.pdf">Netmap: a novel framework for fast packet I/O</a></b>, <i>USENIX ATC</i>, 2012.<br />
<div class="outline-text-5" id="text-org719bc95">
<pre class="example">
RELEVANCE: important
</pre>
<p>
Netmap is a framework that enables commodity operating systems to
handle the millions of packets per seconds, without requiring custom
hardware or changes to applications.  The idea is to eliminate
inefficiencies in OSes' standard packet processing datapaths: per-packet
dynamic memory allocations are removed by preallocating resources, system
call overheads are amortized over large I/O batches, and memory copies are
eliminated by sharing buffers and metadata between kernel and userspace,
while still protecting access to device registers and other kernel memory
areas.
</p>
</div>
</li>

<li><a id="org2f19338"></a>Intel et al.: <b><a href="http://dpdk.org">Intel DPDK: Data Plane Development Kit</a></b>, <i>project website</i>, 2016.<br />
<div class="outline-text-5" id="text-org2f19338">
<pre class="example">
RELEVANCE: important
</pre>
<p>
DPDK is a set of libraries and drivers for fast packet processing,
including a multicore framework, huge page memory, ring buffers, poll-mode
drivers for networking I/O, crypto and eventdev, etc.  DPDK can be used to
receive and send packets within the minimum number of CPU cycles (usually
less than 80 cycles), develop fast packet capture algorithms (like
<code>tcpdump</code>), and run third-party fast path stacks.
</p>
</div>
</li>

<li><a id="org1371dac"></a>fd.io: <b><a href="https://fd.io">The Fast Data Project</a></b>, <i>project website</i>, 2016.<br />
<div class="outline-text-5" id="text-org1371dac">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
FD.io (Fast data – Input/Output) is a collection of several projects and
libraries to support flexible, programmable and composable services on a
generic hardware platform, using a high-throughput, low-latency and
resource-efficient IO services suitable to many architectures (x86, ARM,
and PowerPC) and deployment environments (bare metal, VM, container).
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org739b561" class="outline-3">
<h3 id="org739b561">Hardware Switch Architectures</h3>
<div class="outline-text-3" id="text-org739b561">
<p>
We start off by discussing a first incarnation of a programmable switch,
PLUG, then discuss the SwitchBlade platform and the seminal paper on RMT
(Reconfigurable Match Tables). We then review existing performance
evaluation studies and literature dealing with performance monitoring and
the issue of potential inconsistencies in reconfigurable networks. We
conclude with a paper on Azure SmartNICs based on FPGAs.
</p>
</div>

<ul class="org-ul">
<li><a id="org569d7cb"></a>De Carli et al.: <b><a href="http://doi.acm.org/10.1145/1592568.1592593">PLUG: Flexible Lookup Modules for Rapid Deployment of New Protocols in High-speed Routers</a></b>, <i>ACM SIGCOMM</i>, 2009.<br />
<div class="outline-text-5" id="text-org569d7cb">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
The first incarnation of the "programmable switch". PLUG (Pipelined Lookup
Grid) is a flexible lookup module that can achieve generality without
loosing efficiency, because various custom lookup modules have the same
fundamental features that PLUG retains: area dominated by memories, simple
processing, and strict access patterns defined by the data structure. The
authors IPv4, Ethernet, Ethane, and SEATTLE in a dataflow-based programming
model for the PLUG and mapped them to the PLUG hardware, showing that
throughput, area, power, and latency of PLUGs are close to those of
specialized lookup modules.
</p>
</div>
</li>

<li><a id="org02e07eb"></a>Anwer et al.: <b><a href="http://doi.acm.org/10.1145/1851182.1851206">SwitchBlade: A Platform for Rapid Deployment of Network Protocols on Programmable Hardware</a></b>, <i>ACM SIGCOMM</i>, 2010.<br />
<div class="outline-text-5" id="text-org02e07eb">
<pre class="example">
RELEVANCE: important
</pre>
<p>
SwitchBlade is a platform for rapidly deploying custom protocols on
programmable hardware. SwitchBlade uses a pipeline-based design that allows
individual hardware modules to be enabled or disabled on the fly,
integrates common packet-processing functions as hardware modules enabling
different protocols to use these functions without having to resynthesize
hardware, and uses a customizable forwarding engine that supports both
longest-prefix matching in the packet header and exact matching on a hash
value. SwitchBlade also allows multiple custom data planes to operate in
parallel on the same physical hardware, while providing complete isolation
for protocols running in parallel.
</p>
</div>
</li>

<li><a id="org443b70e"></a>Bosshart et al.: <b><a href="http://doi.acm.org/10.1145/2486001.2486011">Forwarding Metamorphosis: Fast Programmable Match-action Processing in Hardware for SDN</a></b>, <i>ACM SIGCOMM</i>, 2013.<br />
<div class="outline-text-5" id="text-org443b70e">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
This seminal paper presents RMT to overcome two limitations in current
switching chips and OpenFlow: (1) conventional hardware switches are rigid,
allowing "Match-Action" processing on only a fixed set of fields, and (2)
the OpenFlow specification only defines a limited repertoire of packet
processing actions. The RMT (Reconfigurable Match Tables) model is a
RISC-inspired pipelined architecture for switching chips, including an
essential minimal set of action primitives to specify how headers are
processed in hardware. RMT allows the forwarding plane to be changed in the
field without modifying hardware.
</p>
</div>
</li>

<li><a id="org8adf226"></a>Brebner et al.: <b><a href="https://doi.org/10.1109/MM.2014.19">High-Speed Packet Processing using Reconfigurable Computing</a></b>, <i>IEEE Micro</i>, 2014.<br />
<div class="outline-text-5" id="text-org8adf226">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper presents a tool chain that maps a domain-specific declarative
packet-processing language with object-oriented semantics, called PX, to
high-performance reconfigurable-computing architectures based on
field-programmable gate array (FPGA) technology, including components for
packet parsing, editing, and table lookups.
</p>
</div>
</li>

<li><a id="orgab3e8b1"></a>Kuzniar et al.: <b><a href="https://infoscience.epfl.ch/record/199497/files/switches-tr-oct14_1.pdf">What You Need to Know About SDN Control and Data Planes</a></b>, <i>EPFL Technical Report 199497</i>, 2014.<br />
<div class="outline-text-5" id="text-orgab3e8b1">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
The definite source on OpenFlow switches and the differences between them.
The authors measure, report, and explain the performance characteristics of
the control- and data-planes in three hardware OpenFlow switches. The
results highlight differences between the OpenFlow specification and its
implementations that, if ignored, pose a serious threat to network security
and correctness.
</p>
</div>
</li>

<li><a id="orgfc1fcea"></a>Han et al.: <b><a href="https://ieeexplore.ieee.org/document/7110117/">BlueSwitch: Enabling Provably Consistent Configuration of Network Switches</a></b>, <i>ACM/IEEE ANCS</i>, 2015.<br />
<div class="outline-text-5" id="text-orgfc1fcea">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The paper is motivated by the challenges involved in consistent updates of
distributed network configurations, given the complexity of modern switch
datapaths and the exposed opaque configuration mechanisms.  The authors
demonstrate that even simple rule updates result in inconsistent packet
switching in multi-table datapaths.  The main contribution of the paper is
a hardware design that supports a transactional configuration mechanism,
providing strong switch-level atomicity: all packets traversing the
datapath will encounter either the old configuration or the new one, and
never an inconsistent mix of the two. The approach is prototyped using the
NetFPGA hardware platform.
</p>
</div>
</li>

<li><a id="org9ba8227"></a>Li et al.: <b><a href="http://doi.acm.org/10.1145/2934872.2934897">ClickNP: Highly Flexible and High Performance Network Processing with Reconfigurable Hardware</a></b>, <i>ACM SIGCOMM</i>, 2016.<br />
<div class="outline-text-5" id="text-org9ba8227">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
This paper focuses on accelerating NFs with FPGAs. However, FPGA is
predominately programmed using low-level hardware description languages
(HDLs), which are hard to code and difficult to debug. More importantly,
HDLs are almost inaccessible for most software programmers. This paper
presents ClickNP, a FPGA-accelerated platform, which is highly flexible as
it is completely programmable using high-level C-like languages and exposes
a modular programming abstraction that resembles Click Modular Router, and
also high performance.
</p>
</div>
</li>

<li><a id="org43cb0b9"></a>Chole et al.: <b><a href="http://doi.acm.org/10.1145/3098822.3098823">dRMT: Disaggregated Programmable Switching</a></b>, <i>ACM SIGCOMM</i>, 2017.<br />
<div class="outline-text-5" id="text-org43cb0b9">
<pre class="example">
RELEVANCE: important
</pre>
<p>
A follow-up to the RMT paper. dRMT (disaggregated Reconfigurable
Match-Action Table) is a new architecture for programmable switches, which
overcomes two important restrictions of RMT: (1) table memory is local to
an RMT pipeline stage, implying that memory not used by one stage cannot be
reclaimed by another, and (2) RMT is hardwired to always sequentially
execute matches followed by actions as packets traverse pipeline
stages. dRMT resolves both issues by disaggregating the memory and compute
resources of a programmable switch, moving table memories out of pipeline
stages and into a centralized pool that is accessible through a
crossbar. In addition, dRMT replaces RMT's pipeline stages with a cluster
of processors that can execute match and action operations in any order.
</p>
</div>
</li>

<li><a id="org72ce332"></a>Narayana et al.: <b><a href="http://doi.acm.org/10.1145/3098822.3098829">Language-Directed Hardware Design for Network Performance Monitoring</a></b>, <i>ACM SIGCOMM</i>, 2017.<br />
<div class="outline-text-5" id="text-org72ce332">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The authors ask what switch hardware primitives are required to support an
expressive language of network performance questions. They present a
performance query language, Marple, modeled on familiar functional
constructs, backed by a new programmable key-value store primitive on
switch hardware that performs flexible aggregations at line rate and scales
to millions of keys. Marple can express switch queries that could
previously run only on end hosts, while Marple queries only occupy a modest
fraction of a switch's hardware resources.
</p>
</div>
</li>

<li><a id="org3aa2cd2"></a>Daniel Firestone et al.: <b><a href="https://www.usenix.org/conference/nsdi18/presentation/firestone">Azure Accelerated Networking: SmartNICs in the Public Cloud</a></b>, <i>USENIX NSDI</i>, 2018.<br />
<div class="outline-text-5" id="text-org3aa2cd2">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
Modern public cloud architectures rely on complex networking policies and
running the necessary network stacks on CPU cores takes away processing
power from VMs, increasing the cost of running cloud services, and adding
latency and variability to network performance. The paper presents the
design of AccelNet, the Azure Accelerated Networking scheme for offloading
host networking to hardware, using custom Azure SmartNICs based on FPGAs,
including the hardware/software co-design model, performance results on key
workloads, and experiences and lessons learned from developing and
deploying AccelNet.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org032f106" class="outline-3">
<h3 id="org032f106">Hybrid Hardware/Software Architectures</h3>
<div class="outline-text-3" id="text-org032f106">
<p>
It is often believed that the performance of programmable network
processors is lower than hard‐coded chips. There exists interesting
literature questioning this assumption and exploring these overheads
empirically.  We also discuss opportunities coming from Graphics Processing
Units (GPUs) acceleration, e.g., for packet processing, as well as from
hybrid hardware/software architectures in general.
</p>
</div>

<ul class="org-ul">
<li><a id="org25a0c1d"></a>Han et al.: <b><a href="http://doi.acm.org/10.1145/1851182.1851207">PacketShader: A GPU-accelerated Software Router</a></b>, <i>ACM SIGCOMM</i>, 2010.<br />
<div class="outline-text-5" id="text-org25a0c1d">
<pre class="example">
RELEVANCE: important
</pre>
<p>
PacketShader is a high-performance software router framework for general
packet processing with Graphics Processing Unit (GPU) acceleration,
exploiting the massively-parallel processing power of GPU to address the
CPU bottleneck in software routers, combined with a high-performance packet
I/O engine. The paper presents implementations for IPv4 and IPv6
forwarding, OpenFlow switching, and IPsec tunneling to demonstrate the
flexibility and performance advantage of PacketShader. 
</p>
</div>
</li>

<li><a id="orge9a05da"></a>Pongrácz et al.: <b><a href="http://doi.acm.org/10.1145/2491185.2491204">Cheap Silicon: A Myth or Reality Picking the Right Data Plane Hardware for Software Defined Networking</a></b>, <i>ACM HotSDN</i>, 2013.<br />
<div class="outline-text-5" id="text-orge9a05da">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
Industry insight holds that programmable network processors are of lower
performance than their hard-coded counterparts, such as Ethernet chips. The
paper argues that, contrast to the common view, the overhead of
programmability is relatively low, and that the apparent difference between
programmable and hard-coded chips is not primarily due to programmability
itself, but because the internal balance of programmable network processors
is tuned to more complex use cases.
</p>
</div>
</li>

<li><a id="orgbf7255e"></a>Kalia et al.: <b><a href="https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-kalia.pdf">Raising the Bar for Using GPUs in Software Packet Processing</a></b>, <i>USENIX NSDI</i>, 2015.<br />
<div class="outline-text-5" id="text-orgbf7255e">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper opens the debate as to whether Graphics Processing Units (GPUs)
are useful for accelerating software-based routing and packet handling
applications. The authors argue that for many such applications the
benefits arise less from the GPU hardware itself than from the expression
of the problem in a language such as CUDA or OpenCL that facilitates memory
latency hiding and vectorization through massive concurrency. They then
demonstrate that applying a similar style of optimization to algorithm
implementations, a CPU-only implementation is more resource efficient than
the version running on the GPU.
</p>
</div>
</li>

<li><a id="org0dba717"></a>Katta et al.: <b><a href="http://doi.acm.org/10.1145/2890955.2890969">CacheFlow: Dependency-Aware Rule-Caching for Software-Defined Networks</a></b>, <i>ACM SOSR</i>, 2016.<br />
<div class="outline-text-5" id="text-org0dba717">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper presents an architecture to allow high-speed forwarding even with
large rule tables and fast updates, by combining the best of hardware and
software processing. The CacheFlow system caches the most popular rules in
the small TCAM and relies on software to handle the small amount of
cache-miss traffic. The authors observe that one cannot blindly apply
existing cache-replacement algorithms, because of dependencies between
rules with overlapping patterns. Rather long dependency chains must be
broken to cache smaller groups of rules while preserving the semantics of
the policy.
</p>
</div>
</li>

<li><a id="org7ad4049"></a>Kaufmann et al.: <b><a href="http://doi.acm.org/10.1145/2954679.2872367">High Performance Packet Processing with FlexNIC</a></b>, <i>ACM SIGPLAN Not.</i>, 2016.<br />
<div class="outline-text-5" id="text-org7ad4049">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The authors argue that the primary reason for high memory and processing
overheads inherent to packer processing applications is the inefficient use
of the memory and I/O resources by commodity network interface cards
(NICs). They propose FlexNIC, a flexible network DMA interface that can be
used to reduce packet processing overheads; FlexNIC allows services to
install packet processing rules into the NIC, which then executes simple
operations on packets while exchanging them with host memory. This moves
some of the packet processing traditionally done in software to the NIC,
where it can be done flexibly and at high speed.
</p>
</div>
</li>

<li><a id="org93f1762"></a>Younghwan Go et al.: <b><a href="https://www.usenix.org/conference/nsdi17/technical-sessions/presentation/go">APUNet: Revitalizing GPU as Packet Processing Accelerator</a></b>, <i>USENIX NSDI</i>, 2017.<br />
<div class="outline-text-5" id="text-org93f1762">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
This is the answer to the question raised by the "Raising the Bar for Using
GPUs" paper.  Kalia et al. argue that the key enabler for high
packet-processing performance is the inherent feature of GPU that
automatically hides memory access latency rather than its parallel
computation power and claim that CPU can outperform or achieve a similar
performance as GPU if its code is re-arranged to run concurrently with
memory access. This paper revists these claims and find, with eight popular
algorithms widely used in network applications, that (a) there are many
compute-bound algorithms that do benefit from the parallel computation
capacity of GPU while CPU-based optimizations fail to help, and (b) the
relative performance advantage of CPU over GPU in most applications is due
to data transfer bottleneck in PCIe communication of discrete GPU rather
than lack of capacity of GPU itself.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgaa8c1e3" class="outline-2">
<h2 id="orgaa8c1e3">Applications</h2>
<div class="outline-text-2" id="text-orgaa8c1e3">
<p>
A main motivation for programmable data planes are the novel applications
they enable.  We identify and, in the following, will discuss five main
categories: applications related to resilient and efficient forwarding,
in-network computation, consensus, telemetry, and load-balancing.
</p>

<p>
One may wonder, what aspects of SDN and programmable data plane make these
applications possible?  There is probably no single perfect answer to this
question.  
</p>

<p>
Applications related to in-network computation typically leverage new
hardware-assisted primitive operations, supported in the data plane, to
provide novel functionality and improve performance.  Resilient and
efficient routing (and to some extent load-balancing) leverage the unique
and unprecedented programmatic control over the way traffic flows through
the network, e.g., to implement advanced functionality in the data plane
(whereas formerly it used to be handled, e.g., in the control plane).
Measurement applications benefit from the improved traffic visibility
and/or from the improved latency and throughput at which high-volume and
highly variable traffic can be handled, if offloaded to the data plane.
Reduced latency and improved reaction time is arguably also a key reason
for consensus applications.  Furthermore, measurement applications benefit
from the fact that they can be expressed in terms of simple primitives
(e.g., sketches).  We also note that such applications are not limited to
be ``performed (only) in the network'': for example, telemetry can (and
today often does) occur outside the network. That said, telemetry
applications also benefit from the new visibility into the network, e.g.,
queues occupation levels of the switches along the path.  Many interesting
applications also arise from offloading applications that were formerly
handled in a separate middlebox to programmable switches.
</p>

<p>
In general, any application designed for a non-programmable device may
benefit from the flexibilities introduced by a programmable counterpart
(e.g., allowing to evolve the application).  Also, applications with a
strong networking component (e.g., request-response patterns) are more
likely to benefit from in-network services, as much communication traffic
naturally traverses the network anyway.
</p>
</div>

<div id="outline-container-org5ae0b33" class="outline-3">
<h3 id="org5ae0b33">Resilient, Robust, and Efficient Forwarding</h3>
<div class="outline-text-3" id="text-org5ae0b33">
<p>
Data planes often operate much faster than the control plane, which
motivates to move functionality for maintaining connectivity and efficient
routing under failures to the switches. At the same time, implementing such
functionality is non-trivial, as discussed in the following research
papers.
</p>
</div>

<ul class="org-ul">
<li><a id="org392365e"></a>Al-Fares et al.: <b><a href="http://dl.acm.org/citation.cfm?id=1855711.1855730">Hedera: Dynamic Flow Scheduling for Data Center Networks</a></b>, <i>USENIX NSDI</i>, 2010.<br />
<div class="outline-text-5" id="text-org392365e">
<pre class="example">
RELEVANCE: important
</pre>
<p>
This paper is motivated by the limitations of existing IP multipath
protocols relying on per-flow static hashing, which can result in
suboptimal throughput and bandwidth losses due to long-term
collisions. Hedera is a dynamic flow scheduling system for multi-stage
switch topologies as they often appear in data centers. Hedera uses flow
information from constituent switches and reroutes traffic to
non-conflicting routes accordingly. The authors show that the more global
view of routing and traffic demands allows Hedera to see bottlenecks that
switch-local schedulers cannot, and to adaptively schedule the switching
fabric in a way which significantly improves aggregate network utilization
with minimal overheads.
</p>
</div>
</li>

<li><a id="org4f75d92"></a>Liu et al.: <b><a href="https://dblp.org/rec/bib/conf/nsdi/LiuPSGSS13">Ensuring Connectivity via Data Plane Mechanisms</a></b>, <i>USENIX NSDI</i>, 2013.<br />
<div class="outline-text-5" id="text-org4f75d92">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The authors propose to move the responsibility for maintaining basic
network connectivity (as opposed to the computation of optimal paths which
require global control plane knowledge) to the data plane, which operates
orders of magnitude faster than the control plane.  Their Data-Driven
Connectivity (DDC) approach, which can handle arbitrary delays and losses,
relies on simple state changes which can done at packet rates.  In
particular, DCC relies on link reversal routing, adapted to suit the data
plane, e.g., to handle message loss.
</p>
</div>
</li>

<li><a id="orgdc064b7"></a>Borokhovich et al.: <b><a href="https://www.sciencedirect.com/science/article/pii/S0140366416306478">The show must go on: Fundamental data plane connectivity services for dependable SDNs</a></b>, <i>Elsevier ComCom</i>, 2018.<br />
<div class="outline-text-5" id="text-orgdc064b7">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper argues that in order to provide a high availability,
connectivity, and robustness, dependable SDNs must implement functionality
for inband network traversals, e.g., to find failover paths in the presence
link failures. Three fundamentally different mechanisms are described:
simple stateless mechanisms, efficient mechanisms based on packet tagging,
and mechanisms based on dynamic state at the switches.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org0c2dd63" class="outline-3">
<h3 id="org0c2dd63">In-network Computation</h3>
<div class="outline-text-3" id="text-org0c2dd63">
<p>
Offloading computation, on‐path aggregation functionalities, caching, or
even AI, to the network, has the potential to significantly improve the
efficiency of distributed applications.  Accordingly, the study of such
mechanisms have recently received much attention.
</p>
</div>

<ul class="org-ul">
<li><a id="org09ba2d4"></a>Mai et al.: <b><a href="https://dl.acm.org/citation.cfm?id=2674996">Netagg: Using middleboxes for application-specific on-path aggregation in data centres</a></b>, <i>ACM CoNEXT</i>, 2014.<br />
<div class="outline-text-5" id="text-org09ba2d4">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
This paper is motivated by the performance challenges faced by data-center
applications, such as Hadoop batch processing, during the data aggregation
phase: if the network struggles to support many-to-few, high-bandwidth
communication between servers then it can become a bottleneck. Mai et
al. propose to depart from performing data aggregation at edge servers, but
rather, do it more efficiently along network paths. The presented software
platform, NETAGG, supports on-path aggregation for network-bound
partition/aggregation applications. It is based on a middlebox-like design,
in which dedicated servers that can execute aggregation functions provided
by applications. The authors demonstrate that NETAGG can improve throughput
substantially.
</p>
</div>
</li>

<li><a id="org3147430"></a>Graham et al.: <b><a href="https://ieeexplore.ieee.org/document/7830486/">Scalable hierarchical aggregation protocol (SHArP): a hardware architecture for efficient data reduction</a></b>, <i>IEEE COMHPC</i>, 2016.<br />
<div class="outline-text-5" id="text-org3147430">
<pre class="example">
RELEVANCE: important
</pre>
<p>
SHArP is designed to offload computational load to the network, by relying
on intelligent network devices manipulating data traversing the
datacenter. SHArP is implemented in Mellanox’s SwitchIB-2 ASIC, using
in-network trees to reduce data from a group of sources, and to distribute
the result. Multiple parallel jobs with several partially overlapping
groups are supported, and pipelining is used for improving latency further.
</p>
</div>
</li>

<li><a id="orgd400410"></a>Sapio et al.: <b><a href="http://doi.acm.org/10.1145/3152434.3152461">In-Network Computation is a Dumb Idea Whose Time Has Come</a></b>, <i>ACM HotNets</i>, 2017.<br />
<div class="outline-text-5" id="text-orgd400410">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The authors ask the question, given that programmable data plane hardware
creates new opportunities for infusing intelligence into the network, what
kinds of computation should be delegated to the data plane? The paper
discusses the opportunities and challenges for co-designing data center
distributed systems with their network layer, under the constraints imposed
by the limitations of the network machine architecture of programmable
devices. They find that, in particular, aggregation functions raise
opportunities to exploit the limited computation power of networking
hardware to lessen network congestion and improve the overall application
performance.
</p>
</div>
</li>

<li><a id="orgdccea67"></a>Liu et al.: <b><a href="http://doi.acm.org/10.1145/3093315.3037731">IncBricks: Toward In-Network Computation with an In-Network Cache</a></b>, <i>SIGOPS Oper. Syst. Rev.</i>, 2017.<br />
<div class="outline-text-5" id="text-orgdccea67">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
This paper presents IncBricks, an in-network caching fabric with basic
computing primitives. IncBricks is a hardware-software co-designed system
that supports caching in the network using a programmable network
middlebox. As a key-value store accelerator, our prototype lowers request
latency by over 30% and doubles throughput for 1024 byte values in a common
cluster configuration. The results demonstrate the effectiveness of
in-network computing and that efficient datacenter network request
processing is possible if we carefully split the computation across
programmable switches, network accelerators, and end hosts.
</p>
</div>
</li>

<li><a id="org30a692d"></a>Naveen Sharma et al.: <b><a href="https://www.usenix.org/conference/nsdi17/technical-sessions/presentation/sharma">Evaluating the Power of Flexible Packet Processing for Network Resource Allocation</a></b>, <i>USENIX NSDI</i>, 2017.<br />
<div class="outline-text-5" id="text-org30a692d">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The main contribution of this work is providing a set of general building
blocks that mask the limitations of programmable switches (limited state,
support limited types of operations, limited per-packet computation) using
approximation techniques and thereby enabling the implementation of
realistic network protocols. These building blocks are then used to tackle
the network resource allocation problem within datacenters and realize
approximate variants of congestion control and load balancing protocols,
such as XCP, RCP, and CONGA, that require explicit support from the
network. The evaluations show that the proposed approximations are accurate
and that they do not exceed the hardware resource limits associated with
flexible switches.
</p>
</div>
</li>

<li><a id="org1c712e2"></a>Sanvito et al.: <b><a href="https://dl.acm.org/citation.cfm?id=3229594">Can the Network Be the AI Accelerator</a></b>, <i>SIGCOMM NetCompute</i>, 2018.<br />
<div class="outline-text-5" id="text-org1c712e2">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
This paper analyzes the feasibility and opportunities from using
programmable network devices (e.g., network cards and switches), as
accelerators for Artificial Neural Networks (NNs).  In particular, the
authors investigate the properties of NN processing on CPUs, and find that
programmable network devices may indeed be a suitable engine, for
implementing a CPU’s NN co-processor.
</p>
</div>
</li>

<li><a id="org59035b9"></a>Giuseppe Siracusano et al.: <b><a href="http://arxiv.org/abs/1801.05731">In-network Neural Networks</a></b>, <i>unpublished manuscript</i>, 2018.<br />
<div class="outline-text-5" id="text-org59035b9">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The paper presents N2Net, a system that implements binary neural networks
using commodity switching chips deployed in network switches and
routers. N2Net shows that these devices can run simple neural network
models, whose input is encoded in the network packets' header, at packet
processing speeds (billions of packets per second). Furthermore, the
authors' experience highlights that switching chips could support even more
complex models, provided that some minor and cheap modifications to the
chip's design are applied.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org38750f6" class="outline-3">
<h3 id="org38750f6">Distributed Consensus</h3>
<div class="outline-text-3" id="text-org38750f6">
<p>
Another interesting application for programmable data planes is related to
consensus algorithms: the coordination among controllers or switches may be
performed most efficiently directly on the network devices. Over the last
years, several interesting first approaches have been reported in the
literature, not only to compute consensus but also to provide different
notions of consistency more generally.
</p>
</div>

<ul class="org-ul">
<li><a id="org1b4a2c9"></a>Dang et al.: <b><a href="http://doi.acm.org/10.1145/2774993.2774999">NetPaxos: Consensus at Network Speed</a></b>, <i>ACM SOSR</i>, 2015.<br />
<div class="outline-text-5" id="text-org1b4a2c9">
<pre class="example">
RELEVANCE: important
</pre>
<p>
This paper explores the possibility of implementing the widely deployed
Paxos consensus protocol in network devices. Two different approaches are
presented: (1) a detailed design description for implementing the full
Paxos logic in SDN switches, which identifies a sufficient set of required
OpenFlow extensions, and (2) an alternative, optimistic protocol which can
be implemented without changes to the OpenFlow API, but relies on
assumptions about how the network orders messages. Although neither of
these protocols can be fully implemented without changes to the underlying
switch firmware, the authors argue that such changes are feasible in
existing hardware. 
</p>
</div>
</li>

<li><a id="org1516eba"></a>Dang et al.: <b><a href="http://doi.acm.org/10.1145/2935634.2935638">Paxos Made Switch-y</a></b>, <i>ACM SIGCOMM Comput. Commun. Rev.</i>, 2016.<br />
<div class="outline-text-5" id="text-org1516eba">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
This paper posits that there are significant performance benefits to be
gained by implementing the Paxos protocol, the foundation for building many
fault-tolerant distributed systems and services, in network devices. The
paper describes an implementation of Paxos in P4.
</p>
</div>
</li>

<li><a id="org09264bc"></a>Li et al.: <b><a href="https://www.usenix.org/conference/nsdi16/technical-sessions/presentation/li-xiaozhou">Be Fast, Cheap and in Control with SwitchKV</a></b>, <i>USENIX NSDI</i>, 2016.<br />
<div class="outline-text-5" id="text-org09264bc">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
SwitchKV implements a key-value store system leveraging SDN network switches to
balance the cache servers workload routing the traffic based on the content of
the network packets. To identify the content of a packet, the key of a 
key-value entry is encoded in the packet header. A hybrid cache strategy keeps
the cache and switch forwarding rules updated, finally achieving significant
improvements in both system's throughput and latency.
</p>
</div>
</li>

<li><a id="orgf88d26b"></a>Schiff et al.: <b><a href="https://dl.acm.org/citation.cfm?id=2875957">In-band synchronization for distributed SDN control planes</a></b>, <i>SIGCOMM CCR</i>, 2016.<br />
<div class="outline-text-5" id="text-orgf88d26b">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The paper considers the design of consistent distributed control planes in
which the actions performed on the data plane by different controllers need
to be synchronized.  The authors propose a synchronization framework for
based on atomic transactions implemented in the data plane switches and
show that their approach allows to realize fundamental consensus primitives
in the presence of controller failures. They also discuss applications for
consistent policy composition.  With a proof-of-concept implementation, it
is demonstrated that the framework can be implemented using the standard
OpenFlow protocol.
</p>
</div>
</li>

<li><a id="org674c86e"></a>Xin et al.: <b><a href="https://www.usenix.org/conference/nsdi16/technical-sessions/presentation/li-xiaozhou">NetCache: Balancing Key-Value Stores with Fast In-Network Caching</a></b>, <i>ACM SOSP</i>, 2017.<br />
<div class="outline-text-5" id="text-org674c86e">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
NetCache implements a small cache in for key-velue stores in a programmable
hardware switch data plane. The switch works as a cache at the datacenter's
rack level, handling requests directed to the rack's server. The
implementation deals with consistency problems and shows how to overcome
the constraints of hardware to provide throughput and latency improvements.
</p>
</div>
</li>

<li><a id="orgb942413"></a>Xin Jin et al.: <b><a href="https://www.usenix.org/conference/nsdi18/presentation/jin">NetChain: Scale-Free Sub-RTT Coordination</a></b>, <i>USENIX NSDI</i>, 2018.<br />
<div class="outline-text-5" id="text-orgb942413">
<pre class="example">
RELEVANCE: important
</pre>
<p>
This paper presents NetChain, a new approach that provides scale-free
sub-RTT coordination in data centers. NetChain exploits programmable
switches to store data and process queries entirely in the network data
plane. This eliminates the query processing at coordination servers and
cuts the end-to-end latency to as little as half of an RTT.  New protocols
and algorithms are designed for NetChain guarantees strong consistency and
handles switch failures efficiently.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgf7fdbb2" class="outline-3">
<h3 id="orgf7fdbb2">Monitoring, Telemetry, and Measurement</h3>
<div class="outline-text-3" id="text-orgf7fdbb2">
<p>
Perhaps the most interesting applications are related to network
measurement, monitoring and diagnosis. Indeed, programmable data planes can
be a game changer, providing deep insights into the network, even to
end-hosts, as we discuss in the following.
</p>
</div>

<ul class="org-ul">
<li><a id="org9e0d010"></a>Jeyakumar et al.: <b><a href="https://dl.acm.org/citation.cfm?id=2626292">Millions of little minions: Using packets for low latency network programming and visibility</a></b>, <i>SIGCOMM CCR</i>, 2014.<br />
<div class="outline-text-5" id="text-org9e0d010">
<pre class="example">
RELEVANCE: important
</pre>
<p>
Jeyakumar et al. present an approach to give end-hosts visibility into
network behavior and to quickly introduce new data plane functionality, via
a new Tiny Packet Program (TTP) interface. TTPs are embedded into packets
by endhosts and can actively query and manipulate internal network
state. The idea is motivated by a clear work division: switches forward and
execute TTPs in-band at line rate, and endhosts perform arbitrary (and
easily updated) computation on network state. The paper presents a number
of use case descriptions motivating In‐band Network Telemetry (INT).
</p>
</div>
</li>

<li><a id="orge2f11a4"></a>Kim et al.: <b><a href="http://web.mit.edu/anirudh/www/int-demo.pdf">In-band Network Telemetry via Programmable Dataplanes</a></b>, <i>ACM SIGCOMM</i>, 2015.<br />
<div class="outline-text-5" id="text-orge2f11a4">
<pre class="example">
RELEVANCE: important
</pre>
<p>
In-band Network Telemetry (INT) is a powerful new network-diagnostics and
debug mechanism, which allows, e.g., to diagnose performance problems
related to latency spikes. The INT abstraction allows data packets to query
switch-internal state (e.g., queue size, link utilization, and queuing
latency). The paper reports on a prototype implemented in the P4 language,
hence supporting various different programmable network devices.
</p>
</div>
</li>

<li><a id="org518e89b"></a>Gong et al.: <b><a href="http://doi.acm.org/10.1145/2774993.2775068">Towards Accurate Online Traffic Matrix Estimation in Software-defined Networks</a></b>, <i>ACM SOSR</i>, 2015.<br />
<div class="outline-text-5" id="text-org518e89b">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper seeks for accurate, feasible and scalable traffic matrix
estimation approaches, by designing feasible traffic measurement rules that
can be installed in TCAM entries of SDN switches.  The statistics of the
measurement rules are collected by the controller to estimate fine-grained
traffic matrix. Two strategies are proposes, called Maximum Load Rule First
(MLRF) and Large Flow First (LFF), both of which LFF satisfy the flow
aggregation constraints (determined by associated routing policies) and
have low-complexity.
</p>
</div>
</li>

<li><a id="orga590f16"></a>Kim et al.: <b><a href="https://p4.org/assets/INT-current-spec.pdf">In-band Network Telemetry (INT)</a></b>, <i>P4 Consortium</i>, 2015.<br />
<div class="outline-text-5" id="text-orga590f16">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
A specification of In-band Network Telemetry (INT) using P4.
</p>
</div>
</li>

<li><a id="orgfbf2698"></a>Sivaraman et al.: <b><a href="http://doi.acm.org/10.1145/3050220.3063772">Heavy-Hitter Detection Entirely in the Data Plane</a></b>, <i>ACM SOSR</i>, 2017.<br />
<div class="outline-text-5" id="text-orgfbf2698">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper describes HashPipe, a heavy hitter detection algorithm using
programmable data planes. HashPipe implements a pipeline of hash tables
which retain counters for heavy flows while evicting lighter flows over
time. HashPipe is prototyped in P4 and evaluated with packet traces from an
ISP backbone link and a data center.
</p>
</div>
</li>

<li><a id="org016b3a7"></a>Huang et al.: <b><a href="http://doi.acm.org/10.1145/3098822.3098831">SketchVisor: Robust Network Measurement for Software Packet Processing</a></b>, <i>ACM SIGCOMM</i>, 2017.<br />
<div class="outline-text-5" id="text-org016b3a7">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper presents SketchVisor, a robust network measurement framework,
which augments sketch-based measurement in the data plane with a fast path
that is activated under high traffic load to provide high-performance local
measurement with slight accuracy degradation. It further recovers accurate
network-wide measurement results via compressive sensing. A SketchVisor
prototype is build on top of Open vSwitch; testbed experiments show that
SketchVisor achieves high throughput and high accuracy for a wide range of
network measurement tasks.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgb7b49da" class="outline-3">
<h3 id="orgb7b49da">Load balancing</h3>
<div class="outline-text-3" id="text-orgb7b49da">
<p>
Last but not least, and similarly to the above discussion on resilient
routing, programmable data planes provide unprecedented flexibilities (and
performance) in how traffic can be dynamically load-balanced.
</p>
</div>

<ul class="org-ul">
<li><a id="orgcce27dc"></a>Katta et al.: <b><a href="https://conferences.sigcomm.org/sosr/2016/papers/sosr_paper67.pdf">Hula: Scalable load balancing using programmable data planes</a></b>, <i>ACM SOSR</i>, 2016.<br />
<div class="outline-text-5" id="text-orgcce27dc">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
HULA is motivated by the shortcomings of ECMP as well as of existing
congestion-aware load-balancing techniques such as CONGA, which, due to
limited switch memory, can only maintain a limited amount of
congestion-tracking state at the edge switches, and hence do not
scale. HULA is a more flexible and scalable data-plane load-balancing
algorithm in which each switch tracks congestion only for the best path to
a destination through a neighboring switch. HULA is designed for
programmable switches and is programmed in P4.
</p>
</div>
</li>

<li><a id="orgeba0fb5"></a>Miao et al.: <b><a href="http://doi.acm.org/10.1145/3098822.3098824">SilkRoad: Making Stateful Layer-4 Load Balancing Fast and Cheap Using Switching ASICs</a></b>, <i>ACM SIGCOMM</i>, 2017.<br />
<div class="outline-text-5" id="text-orgeba0fb5">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper explores how to use programmable switching ASICs to build much
faster load balancers than have been built before. The proposed system,
called SilkRoad, is defined in a 400 lines of P4 and, when compiled to a
state-of-the-art switching ASIC, it can load-balance ten million
connections simultaneously at line rate.
</p>
</div>
</li>

<li><a id="orgd402760"></a>Bremler-Barr et al.: <b><a href="https://ieeexplore.ieee.org/document/8264855/">Load Balancing Memcached Traffic Using Software Defined Networking</a></b>, <i>IFIP Networking</i>, 2017.<br />
<div class="outline-text-5" id="text-orgd402760">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
Memcached is an in-memory key-value distributed caching solution, commonly
used by web servers for fast content delivery. In order to deal with skewed
distributions of key popularity in key-value stores, the authors propose
and implement MBalancer, a switch-based L7 load balancing scheme, which
offloads requests from bottleneck Memcached servers.  MBalancer runs as an
SDN application, identifies the (typically small number of) hot keys,
duplicates these hot keys to many (or all) Memcached servers, and adjusts
the switches' forwarding tables accordingly. Experiences with an
implementation of MBalancer on a hardware-based OpenFlow switch indicate
significant throughput boost and latency reduction.
</p>
</div>
</li>

<li><a id="org5326b60"></a>Ghasemi et al.: <b><a href="https://dl.acm.org/citation.cfm?id=3050228">Dapper: Data plane performance diagnosis of TCP</a></b>, <i>ACM SOSR</i>, 2017.<br />
<div class="outline-text-5" id="text-org5326b60">
<pre class="example">
RELEVANCE: important
</pre>
<p>
Dapper is a system which leverages emerging edge devices offering flexible
and high-speed packet processing on commodity hardware, to diagnose cloud
performance problems in a timely manner. In particular, Dapper analyzes TCP
performance in real time near the end-hosts, i.e., at the hypervisor, NIC,
or top-of-rack switch, by determining whether a connection is limited by
the sender, the network, or the receiver. Dapper was prototyped in P4.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org6d5b91d" class="outline-2">
<h2 id="org6d5b91d">Miscellaneous Topics</h2>
<div class="outline-text-2" id="text-org6d5b91d">
<p>
There exists highly recommendable literature on the history of SDN and
programmable data planes. We also report on two other important topics,
deployment and algorithms of programmable data planes.
</p>
</div>

<div id="outline-container-orgd3b5f65" class="outline-3">
<h3 id="orgd3b5f65">History</h3>
<div class="outline-text-3" id="text-orgd3b5f65">
<p>
There are several interesting papers putting the technological trends
around programmable networks into a historic perspective.
</p>
</div>

<ul class="org-ul">
<li><a id="orgbd60fc3"></a>Schwartz et al.: <b><a href="https://dl.acm.org/citation.cfm?id=332893">Smart packets: Applying active networks to network management</a></b>, <i>ACM TOCS</i>, 2000.<br />
<div class="outline-text-5" id="text-orgbd60fc3">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
One intellectual precursor to programmable networks is the Active Networks
concept. This paper surveys the application of active networks technology
to network management and monitoring. The main idea of Smart Packets, which
contain programs written in a safe language, is to move management decision
points closer to the nodes being managed, as well as to target specific
aspects of the node for information.
</p>
</div>
</li>

<li><a id="org7fd0d76"></a>Feamster et al.: <b><a href="http://doi.acm.org/10.1145/2559899.2560327">The Road to SDN</a></b>, <i>ACM Queue</i>, 2013.<br />
<div class="outline-text-5" id="text-org7fd0d76">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
An intellectual history of programmable networks. A mustread.
</p>
</div>
</li>

<li><a id="org123f4fb"></a>Zilberman et al.: <b><a href="https://doi.org/10.1109/JPROC.2015.2435732">Reconfigurable Network Systems and Software-Defined Networking</a></b>, <i>Proceedings of the IEEE</i>, 2015.<br />
<div class="outline-text-5" id="text-org123f4fb">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper reviews the state of the art in reconfigurable network systems,
covering hardware reconfiguration, SDN, and the interplay between them. It
starts with a tutorial on software-defined networks, then continues to
discuss programming languages as the linking element between different
levels of software and hardware in the network, reviews electronic
switching systems, highlighting programmability and reconfiguration
aspects, and describes the trends in reconfigurable network
elements.
</p>
</div>
</li>

<li><a id="org3b03a79"></a>Nick McKeown et al.: <b><a href="https://conferences.sigcomm.org/sigcomm/2017/files/program-netpl/01-mckeown.pptx">Programmable Forwarding Planes are Here to Stay</a></b>, <i>ACM SIGCOMM NetPL</i>, 2017.<br />
<div class="outline-text-5" id="text-org3b03a79">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
A keynote from Nick McKeown at NetPL'17 on the many great research ideas
and new languages that have emerged for programmable forwarding. The talk
considers how we got here, why programmable forwarding planes are
inevitable, why now is the right time, why they are a final frontier for
SDN, and why they are here to stay.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org679d3c5" class="outline-3">
<h3 id="org679d3c5">Deployments</h3>
<div class="outline-text-3" id="text-org679d3c5">
<p>
A very relevant question, which is also a research challenge, regards the
deployment of SDN and programmable data planes.
</p>
</div>

<ul class="org-ul">
<li><a id="orga3d3d60"></a>Casado et al.: <b><a href="http://doi.acm.org/10.1145/1282380.1282382">Ethane: Taking Control of the Enterprise</a></b>, <i>ACM SIGCOMM</i>, 2007.<br />
<div class="outline-text-5" id="text-orga3d3d60">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
A seminal paper for deploying SDN in enterprise networks, this paper
presents Ethane, a network architecture allowing managers to define a
single network-wide fine-grain policy and then enforcing it
directly. Ethane couples extremely simple flow-based Ethernet switches with
a centralized controller that manages the admittance and routing of
flows. While radical, this design is backwards-compatible with existing
hosts and switches.  Ethane was implemented in both hardware and software,
supporting both wired and wireless hosts.
</p>
</div>
</li>

<li><a id="org6e5f79f"></a>Jin et al.: <b><a href="https://conferences.sigcomm.org/co-next/2013/program/p163.pdf">Softcell: Scalable and flexible cellular core network architecture</a></b>, <i>ACM CoNEXT</i>, 2013.<br />
<div class="outline-text-5" id="text-org6e5f79f">
<pre class="example">
RELEVANCE: important
</pre>
<p>
SoftCell aims to overcome today's expensive, inflexible and complex
cellular core networks by supporting fine-grained policies for mobile
devices, using commodity switches and servers.  In particular, SoftCell
allows to flexibly route traffic through sequences of middleboxes based on
subscriber attributes and applications.  Scalability is achieved by
minimizing the size of the forwarding tables, using aggregation, and by
performing packet classification at the access switches, next to the base
stations.
</p>
</div>
</li>

<li><a id="org8b1aec4"></a>Jain et al.: <b><a href="http://doi.acm.org/10.1145/2486001.2486019">B4: Experience with a Globally-deployed Software Defined Wan</a></b>, <i>ACM SIGCOMM</i>, 2013.<br />
<div class="outline-text-5" id="text-org8b1aec4">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The paper presents the design, implementation, and evaluation of B4, a
private WAN connecting Google's data centers across the planet. B4 has a
number of unique characteristics: (1) massive bandwidth requirements
deployed to a modest number of sites, (2) elastic traffic demand that seeks
to maximize average bandwidth, and (3) full control over the edge servers
and network, which enables rate limiting and demand measurement at the
edge. These characteristics led to a Software Defined Networking architecture
using OpenFlow to control relatively simple switches built from merchant
silicon.
</p>
</div>
</li>

<li><a id="org606cd11"></a>Qazi et al.: <b><a href="http://doi.acm.org/10.1145/3098822.3098848">A High Performance Packet Core for Next Generation Cellular Networks</a></b>, <i>ACM SIGCOMM</i>, 2017.<br />
<div class="outline-text-5" id="text-org606cd11">
<pre class="example">
RELEVANCE: important
</pre>
<p>
To support deploying SDNs into the Evolved Packet Core (EPC), the paper
presents the design and evaluation of a system architecture for a software
EPC that achieves high and scalable performance. The authors postulate that
the poor scaling of existing EPC systems stems from the manner in which the
system is decomposed, which leads to device state being duplicated across
multiple components, which in turn results in frequent interactions between
the different components. An alternate approach is proposed in which state
for a single device is consolidated in one location and EPC functions are
reorganized for efficient access to this consolidated state. A prototype
for PEPC is also presented, as a software EPC that implements the key
components of the design.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgbe789c8" class="outline-3">
<h3 id="orgbe789c8">Implementing the Match-action Abstraction: HW, Algorithms, and Data Structures</h3>
<div class="outline-text-3" id="text-orgbe789c8">
<p>
Another very research relevant area regards the design of algorithms and
data planes for this new technology.
</p>
</div>

<ul class="org-ul">
<li><a id="orgbc3bb06"></a>Srinivasan et al.: <b><a href="http://doi.acm.org/10.1145/316188.316216">Packet Classification Using Tuple Space Search</a></b>, <i>ACM SIGCOMM</i>, 1999.<br />
<div class="outline-text-5" id="text-orgbc3bb06">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
This paper presents the packet classifier algorithm that underlies the Open
vSwitch fast-path. Packet classification requires matching each packet
against a database of flow rules and forwarding the packet according to the
highest priority rule. The paper introduces a generic packet classification
algorithm, called Tuple Space Search (TSS), based on the observation that
real databases typically use only a small number of distinct field lengths.
Thus, by mapping rules to tuples even a simple linear search of the tuple
space can provide significant speedup over naive linear search over the
filters. Each tuple is maintained as a hash table that can be searched in
one memory access. 
</p>
</div>
</li>

<li><a id="orgb3aaff0"></a>Pagiamtzis et al.: <b><a href="https://www.pagiamtzis.com/pubs/pagiamtzis-jssc2006.pdf">Content-addressable memory (CAM) circuits and architectures: A tutorial and survey</a></b>, <i>IEEE Journal of Solid-State Circuits</i>, 2006.<br />
<div class="outline-text-5" id="text-orgb3aaff0">
<pre class="example">
RELEVANCE: important
</pre>
<p>
Content-addressable memory (CAM) and Ternary CAM (TCAM) chips are the most
important component in programmable switch ASICs, performing packet
classification according to configurable header fields, matching rules, and
priority, in a single clock cycle using dedicated comparison circuitry. The
paper surveys recent developments in the design of large-capacity CAMs. The
main CAM-design challenge is to reduce power consumption associated with
the large amount of parallel active circuitry, without sacrificing speed or
memory density. The paper reviews CAM-design techniques at the circuit
level and at the architectural level.
</p>
</div>
</li>

<li><a id="org2c25aa8"></a>Fu et al.: <b><a href="http://doi.acm.org/10.1145/1544012.1544033">Efficient IP-address Lookup with a Shared Forwarding Table for Multiple Virtual Routers</a></b>, <i>ACM CoNEXT</i>, 2008.<br />
<div class="outline-text-5" id="text-org2c25aa8">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
Programmable routers often need to support a separate forwarding
information base (FIB) for each virtual router provisioned by the
controller, which leads to memory scaling challenges. In this paper, a
small, shared FIB data structure is presented and a fast lookup algorithm
that capitalize on the commonality of IP prefixes between each
FIB. Experiments with real packet traces and routing tables show that the
approach achieves much lower memory requirements and considerably faster
lookup times.
</p>
</div>
</li>

<li><a id="org377512b"></a>Ma et al.: <b><a href="http://doi.acm.org/10.1145/2377677.2377749">A Smart Pre-classifier to Reduce Power Consumption of TCAMs for Multi-dimensional Packet Classification</a></b>, <i>ACM SIGCOMM Comput. Commun. Rev.</i>, 2012.<br />
<div class="outline-text-5" id="text-org377512b">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
Ternary Content-Addressable Memories (TCAMs) have become the industrial
standard for high-throughput packet classification, and as such, for
programmable switch ASICs. However, one major drawback of TCAMs is their
high power consumption. In this paper, a practical and efficient solution
is proposed which introduces a smart pre-classifier to reduce power
consumption of TCAMs for multi-dimensional packet classification. The
classifier dimension is reduced by pre-classifying a packet on two header
fields, source and destination IP addresses. Then, the high dimensional
problem can use only a small portion of a TCAM for a given packet. The
pre-classifier is built such that a given packet matches at most one entry
in the pre-classifier, and each rule is stored only once in one of the TCAM
blocks, which avoids rule replication. The presented solution uses
commodity TCAMs.
</p>
</div>
</li>

<li><a id="orgd060a1a"></a>Zhou et al.: <b><a href="http://doi.acm.org/10.1145/2535372.2535379">Scalable, High Performance Ethernet Forwarding with CuckooSwitch</a></b>, <i>ACM CoNEXT</i>, 2013.<br />
<div class="outline-text-5" id="text-orgd060a1a">
<pre class="example">
RELEVANCE: important
</pre>
<p>
Programmable switches usually need to implement some or more match-action
tables in the fast-path.  This paper presents CuckooSwitch, a
software-based switch design built around a memory-efficient,
high-performance, and highly-concurrent hash table for compact and fast FIB
lookup. The authors show that CuckooSwitch can process the maximum packets
per second rate achievable across the underlying hardware's PCI buses while
maintaining a forwarding table of one billion forwarding entries.
</p>
</div>
</li>

<li><a id="org747b018"></a>Rétvári et al.: <b><a href="http://doi.acm.org/10.1145/2486001.2486009">Compressing IP Forwarding Tables: Towards Entropy Bounds and Beyond</a></b>, <i>ACM SIGCOMM</i>, 2013.<br />
<div class="outline-text-5" id="text-org747b018">
<pre class="example">
RELEVANCE: mustread
</pre>
<p>
The main goal of this paper is to demonstrate how data compression can
benefit the networking community, by showing how to squeeze the
longest-prefix-matching lookup table, consulted by switches for IP lookup,
into information-theoretical entropy bounds with essentially zero cost on
lookup performance and FIB update. The state-of-the-art in compressed data
structures yields a static entropy-compressed FIB representation with
asymptotically optimal lookup. Since this data structure results too slow
for practical uses, the authors redesign the venerable prefix tree to also
admit entropy bounds and support lookup in optimal time and update in
nearly optimal time.
</p>
</div>
</li>

<li><a id="org3d0c062"></a>Kogan et al.: <b><a href="http://doi.acm.org/10.1145/2619239.2626294">SAX-PAC (Scalable And eXpressive PAcket Classification)</a></b>, <i>ACM SIGCOMM</i>, 2014.<br />
<div class="outline-text-5" id="text-org3d0c062">
<pre class="example">
RELEVANCE: important
</pre>
<p>
Efficient packet classification is a core concern for programmable network
devices, but it is also very difficult to implement
efficiently. Traditional multi-field classification approaches, in both
software and ternary content-addressable memory (TCAMs), entail trade-offs
between (memory) space and (lookup) time. In this work, a novel approach is
presented, which identifies properties of many classifiers that can be
implemented in linear space and with worst-case guaranteed logarithmic time
and allows the addition of more fields including range constraints without
impacting space and time complexities.
</p>
</div>
</li>

<li><a id="org329b762"></a>Bifulco et al.: <b><a href="http://doi.acm.org/10.1145/2785956.2790008">Towards Scalable SDN Switches: Enabling Faster Flow Table Entries Installation</a></b>, <i>ACM SIGCOMM</i>, 2015.<br />
<div class="outline-text-5" id="text-org329b762">
<pre class="example">
RELEVANCE: important
</pre>
<p>
The authors argue that a hybrid software-hardware switch may help in
lowering the flow-table entries installation time, and present ShadowSwitch
(sSw), an OpenFlow switch prototype that implements such a design. sSw
builds on two key observations. First, software tables are very fast to be
updated, hence, forwarding tables updates always happen in software first
and, eventually, entries are moved to the TCAM to achieve higher overall
throughput and offload the software forwarder. Lookup in software is
performed only in case there are no entries matching a packet in
hardware. Second, since deleting entries from TCAM is much faster than
adding them, ShadowSwitch may translate an entry installation in a mix of
installation in software tables and deletion from hardware tables.
</p>
</div>
</li>

<li><a id="org037fadf"></a>Chen et al.: <b><a href="http://doi.acm.org/10.1145/3143361.3143391">Hermes: Providing Tight Control over High-Performance SDN Switches</a></b>, <i>ACM CoNEXT</i>, 2017.<br />
<div class="outline-text-5" id="text-org037fadf">
<pre class="example">
RELEVANCE: interesting
</pre>
<p>
The paper presents the design and evaluation of Hermes, a practical and
immediately deployable framework that offers a novel method for
partitioning and optimizing switch TCAM to enable performance guarantees
for control plane actions, in particular, inserting, modifying, or deleting
rules. Hermes provides these guarantees by trading-off a nominal amount of
TCAM space for assured performance.
</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Roberto Bifulco, Stefan Schmid, Gábor Rétvári</p>
<p class="date">Created: 2018-11-05 Mon 20:57</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
